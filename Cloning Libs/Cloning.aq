{"config":{"title":"Cloning","description":"No description given","copyright":"No copyright declared","version":"no version info","authors":[],"maintainer":{"name":"No maintainer","email":"noone@nowehere"},"acknowledgements":[],"github":{"repo":"none","user":"none","access_token":"none"},"keywords":[],"aquadoc_version":"1.0.0"},"components":[{"library":{"name":"Cloning","category":"Cloning Libs","code_source":"module Cloning\n  require 'net/smtp'\n\n  def check_concentration operations, input_name\n    items = operations.collect { |op| op.input_array(input_name).items.select { |i| i.get(:concentration).nil? } }.flatten.uniq\n    \n    cc = show do\n      title \"Please nanodrop the following #{items.first.object_type.name.pluralize}\"\n      note \"Please nanodrop the following #{items.first.object_type.name.pluralize}:\"\n      items.each do |i|\n        get \"number\", var: \"c#{i.id}\", label: \"#{i} item\", default: 42\n      end\n    end if items.any?\n    \n    items.each do |i|\n      i.associate(:concentration, cc[\"c#{i.id}\".to_sym])\n      i.save\n    end\n  end\n  \n    \n  # The check_volumes method will have the lab tech ensure that the given input item volumes are above a certain minimum amount, \n  # for each operation. The inputs to check are specified in an array parameter. \n  # The minimum volume is specified in mL on a per-operation basis using the the value stored in op.temporary[\u003cvol_sym\u003e],\n  # where vol_sym is a symbol name of your choice.\n  # Contamination can be checked for too, with the additional option parameter check_contam: true\n  # After determining which inputs for which ops are low volume, this method passes off a hash of 'items -\u003e lists of ops' to your rebuilder function specified by name as string or symbol in the callback argument.\n  # when the callback method returns, check_volumes loops back and checks the volumes again of the newly assigned unverified input items, and repeats this loop until all given inputs for all ops are verified for their volume.\n  # for a detailed example of how this method can be used, look at the method call in make PCR fragment, and the callback function make_aliquots_from_stock\n  def check_volumes inputs, vol_sym, callback, options = {}\n    \n    ops_by_item = Hash.new(0)\n    operations.running.each do |op|\n      inputs.each do |input|\n        if ops_by_item.keys.include? op.input(input).item\n          ops_by_item[op.input(input).item].push op\n        else\n          ops_by_item[op.input(input).item] = [op] \n        end\n      end\n    end\n      \n    # while any operations for any of the specified inputs are unverified, check the volumes again and send any bad op/input combos to rebuilder function\n    while ops_by_item.keys.any?\n      verify_data = show do\n        title \"Verify enough volume of each #{inputs.to_sentence(last_word_connector: \", or\")} exists#{options[:check_contam] ? \", or note if contamination is present\" : \"\"}\"\n        \n        ops_by_item.each do |item, ops| \n          volume = 0.0\n          ops.each { |op| volume += op.temporary[vol_sym] }\n          volume = (volume*100).round / 100.0\n          choices = options[:check_contam] ? [\"Yes\", \"No\", \"Contamination is present\"] : [\"Yes\", \"No\"]\n          select choices, var: \"#{item.id}\", label: \"Is there at least #{volume} µL of #{item.id}?\", default: 0\n        end\n      end\n      ops_by_item.each do |item, ops|\n        if verify_data[\"#{item.id}\".to_sym] == \"Yes\"\n          ops_by_item.except! item\n        elsif verify_data[\"#{item.id}\".to_sym] == \"Contamination is present\"\n          item.associate(:contaminated, \"Yes\")\n          item.save\n        end\n      end\n      method(callback.to_sym).call(ops_by_item, inputs) if ops_by_item.keys.any?\n    end\n  end\n  \n  # a common callback for check_volume.\n  # takes in lists of all ops that have input aliquots with insufficient volume, sorted by item,\n  # and takes in the inputs which were checked for those ops.\n  # Deletes bad items and remakes each primer aliquots from primer stock\n  def make_aliquots_from_stock bad_ops_by_item, inputs\n    # bad_ops_by_item is accessible by bad_ops_by_item[item] = [op1, op2, op3...]\n    # where each op has a bad volume reading for the given item\n    \n    # Construct list of all stocks needed for making aliquots. Error ops for which no primer stock is available\n    # for every non-errored op that has low item volume,\n    # replace the old aliquot item with a new one. \n    aliquots_to_make = 0\n    stocks = []\n    ops_by_fresh_item = Hash.new(0)\n    found_items = []\n    stock_table = [[\"Primer Stock ID\", \"Primer Aliquot ID\"]]\n    transfer_table = [[\"Old Aliquot ID\", \"New Aliquot ID\"]]\n    bad_ops_by_item.each do |item, ops|\n        \n      #first, check to see if there is a replacement aliquot availalbe in the inventory\n      fresh_item = item.sample.in(\"Primer Aliquot\").reject {|i| i == item }.first\n      \n      if fresh_item\n        #if a replacement item was found in the inventory, snag it\n        found_items.push fresh_item\n      else\n        # no replacement, found, lets try making one.\n        stock = item.sample.in(\"Primer Stock\").first\n        if stock.nil?\n          # no stock found, replacement could not be made or found: erroring operation\n          ops.each { |op| op.error :no_primer_stock, \"aliquot #{item.id} was bad and a replacement could not be made. You need to order a primer stock for primer sample #{item.sample.id}.\" }\n          bad_ops_by_item.except! item\n        else\n          stocks.push stock\n          aliquots_to_make += 1\n          fresh_item = produce new_sample item.sample.name, of: item.sample.sample_type.name, as: item.object_type.name\n          stock_table.push [stock.id, {content: fresh_item.id, check: true}]\n        end\n      end\n      \n      if fresh_item\n        # for the items where a replacement is able to be found or made, update op item info\n        item.mark_as_deleted\n        bad_ops_by_item.except! item\n        ops_by_fresh_item[fresh_item] = ops\n        ops.each do |op| \n          input = inputs.find { |input| op.input(input).item == item }\n          op.input(input).set item: fresh_item\n        end\n        if item.get(:contaminated) != \"Yes\"\n          transfer_table.push [item.id, {content: fresh_item.id, check: true}]    \n        end\n      end\n    end\n    \n    take found_items, interactive: true if found_items.any?\n    #items are guilty untill proven innocent. all the fresh items will be put back into the list of items to check for volume\n    bad_ops_by_item.merge! ops_by_fresh_item\n    take stocks, interactive: true if stocks.any?\n    \n    # label new aliquot tubes and dilute\n    show do \n      title \"Grab 1.5 mL tubes\"\n      \n      note \"Grab #{aliquots_to_make} 1.5 mL tubes\"\n      note \"Label each tube with the following ids: #{bad_ops_by_item.keys.reject { |item| found_items.include? item }.map { |item| item.id }.sort.to_sentence}\"\n      note \"Using the 100 uL pipette, pipette 90 µl of water into each tube\"\n    end if bad_ops_by_item.keys.reject { |item| found_items.include? item }.any?\n  \n    # make new aliquots\n    show do \n      title \"Transfer primer stock into primer aliquot\"\n      \n      note \"Pipette 10 uL of the primer stock into the primer aliquot according to the following table:\"\n      table stock_table\n    end if stocks.any?\n    \n    \n    if transfer_table.length \u003e 1\n      show do\n        title \"Transfer Residual Primer\"\n        \n        note \"Transfer primer residue from the low volume aliquots into the fresh aliquots according to the following table:\"\n        table transfer_table\n      end\n    end\n    \n    release stocks, interactive: true if stocks.any?\n  end\n\n  \n  \n  \n  # Associates specified associations + uploads from :from to :to. This is used primarily to pass sequencing results through items in a plasmid's lineage\n  #   e.g., pass_data \"sequence_verified\", \"sequencing results\", from: overnight, to: glycerol_stock\n  #   This will copy all sequencing results and the sequence_verified associations from the overnight to the glycerol stock\n  def pass_data *names, **kwargs\n    from = kwargs[:from]\n    to = kwargs[:to]\n    names.each do |name|\n      keys = from.associations.keys.select { |k| k.include? name }\n      keys.each do |k|\n        to.associate k, from.get(k), from.upload(k)\n      end\n    end\n  end\n  \n  \n  # Takes an array of items as input and asks the user if they would like to dispose of them. If note (string) is also given then this will be displayed to the user as well\n  # Note that this doesn't store items the user doesn't want to get rid of.\n  # Example: ask_to_delete items, \"Discard empty tubes.\"\n  def ask_to_delete items, note=nil\n    data = show do\n        title \"Select any items to delete\"\n        note note if not note.blank?\n        items.each_with_index { |item, item_index| select [ \"Keep this item\", \"Delete this item\" ], var: \"#{item_index}\", label: \"#{item.sample.name} (#{item.id})\", default: 0}\n    end\n    data.each do |key, choice|\n        if choice == \"Delete this item\"\n            items[key.to_s.to_i].mark_as_deleted\n        end\n    end\n  end\n  \n  \n  # Takes an item as input and (optionally) a number to get out, returns a string as output which says \"If more samplename is needed, get out itemID1 (location), itemID2 (location), etc.\" \n  # \"start\" argument determines which item to show. This should usually be set to be equal to the number of items of this type that the user currently has out already.\n  # Default number of extra items to show is 1.\n  # Example 1: find_more dNTP_item\n  # Example 2: find_more dNTP_item, 2\n  def find_more item, start=1, number=1\n    sample_name = item.sample.name\n    object_type = item.object_type\n    items = Array(find(:sample, name: sample_name)[0].in(object_type.name)[start..number])\n    items_and_locs = items.map {|i| i.id.to_s + \" (\" + i.location + \")\"}\n    if items_and_locs.empty?\n        return \"There are no extra #{sample_name} items other than the one you are using. Consider ordering/making more.\"\n    else\n        return \"If more #{sample_name} is needed, get out #{items_and_locs.to_sentence} and put away when done.\"\n    end\n  end\n  \n  # Used after actions which may cause operations to error. Informs the technician of how many have errored. Also, returns true if all are errored.\n  def check_for_errors\n    new_errored_ops = operations.errored.select{|op| !(op.temporary[:sent_error_message] == true)}\n    if new_errored_ops.count \u003e 0\n        errored_users = new_errored_ops.map{|op| User.find(op.user_id).name}.uniq.to_sentence\n        data = show do\n            title \"Some of the scheduled operations have been cancelled\"\n            warning \"A total of #{operations.errored.count}/#{operations.count} operations have been cancelled due to errors.\"\n            select [\"Send email\", \"Do not send\"], var: \"email_choice\", label: \"Would you like to notify #{errored_users} by email that the following operations have been cancelled?\", default: 0\n            new_errored_ops.each do |op|\n                note op.associations.map{|key, value| \"\u003cb\u003eOperation ID:\u003c/b\u003e #{op.id} \u003cb\u003eOperation Name:\u003c/b\u003e #{op.name} \u003cb\u003eInfo:\u003c/b\u003e #{key}, #{value}\"}.join(\"\\n\")\n            end\n        end\n        new_errored_ops.each{|op| op.temporary[:sent_error_message] = true}\n        \n        if data[:email_choice] == \"Send email\"\n            send_error_emails new_errored_ops\n        end\n        \n        if operations.running.count == 0\n            return true\n        else\n            return false\n        end\n    end\n  end\n  \n  # Centrifugation. Takes a list of items or list of IDs or (string and a number), rpm or rcf value, and an amount of time. Tells the user to centrifuge the items and shows how to balance that number of tubes in a 24-hole \n  # microcentrifuge. Number argument is not required unlesss using a string as items.\n  \n  #def centrifuge_items(items:, number:, rpm:, rcf:, min:)\n    #stuff\n  #end\n\n  #centrifuge_items(items: items, rpm: 1000, min: 3)\n  \n  \n  \n    #def set_inputs_within_spec operations, input_name, min_conc, min_amount\n    #    operations.each do |op|\n    #        type = op.input(input_name).object_type\n    #        sample = op.input(input_name).sample\n    #        items_by_info = sample.items.partition {|i| (i.get :concentration).present? \u0026\u0026 (i.get :volume).present?}\n    #        items_meeting_spec = items_by_info[0].select {|i| (i.get :concentration) \u003e= min_conc \u0026\u0026 1.1*(i.get :concentration)*(i.get :volume) \u003e= min_amount}\n    #        if items_meeting_spec.any?\n    #            op.input(\"Enzyme\").set item: items_meeting_spec.first\n    #        else\n    #            \n    #            op.error :no_suitable_inputs, \"No items of #{sample.name} meet minimum specifications for protocol.\"\n    #        end\n    #    end\n    #    show do\n    #        \n    #    end\n    #end\n    \n    \n    \n    \n    \n  # a NEW EXPERIMENTAL callback for check_volume.\n  # takes in lists of all ops that have input aliquots with insufficient volume, sorted by item,\n  # and takes in the inputs which were checked for those ops.\n  # Deletes bad items and replaces with \"stock\" enzymes (moving them from stock to aliquot)\n  def make_enzyme_aliquots_from_stock bad_ops_by_item, inputs\n    # bad_ops_by_item is accessible by bad_ops_by_item[item] = [op1, op2, op3...]\n    # where each op has a bad volume reading for the given item\n    \n    # Construct list of all stocks needed for making aliquots. Error ops for which no primer stock is available\n    # for every non-errored op that has low item volume,\n    # replace the old aliquot item with a new one. \n    aliquots_to_make = 0\n    stocks = []\n    ops_by_fresh_item = Hash.new(0)\n    found_items = []\n    stock_table = [[\"Enzyme Stock Name\", \"Enzyme Aliquot ID (new item)\"]]\n    transfer_table = [[\"Old Aliquot ID\", \"New Aliquot ID\"]]\n    bad_ops_by_item.each do |item, ops|\n        \n      #first, check to see if there is a replacement aliquot availalbe in the inventory\n      fresh_item = item.sample.in(\"Enzyme Work Solution\").reject {|i| i == item }.first\n      \n      if fresh_item\n        #if a replacement item was found in the inventory, snag it\n        found_items.push fresh_item\n      else\n        # no replacement, found, lets try making one.\n        stock = item.sample.in(\"Enzyme Stock\").first\n        if stock.nil?\n          # no stock found, replacement could not be made or found: erroring operation\n          ops.each { |op| op.error :no_primer_stock, \"Aliquot #{item.id} was bad and a replacement could not be made. You need to order an enzyme stock for sample #{item.sample.id}.\" }\n          bad_ops_by_item.except! item\n        else\n          stocks.push stock\n          aliquots_to_make += 1\n          fresh_item = produce new_sample item.sample.name, of: item.sample.sample_type.name, as: item.object_type.name\n          stock_table.push [\"#{stock.sample.name} (old ID: #{stock.id})\", {content: fresh_item.id, check: true}]\n        end\n      end\n      \n      if fresh_item\n        # for the items where a replacement is able to be found or made, update op item info\n        item.mark_as_deleted\n        bad_ops_by_item.except! item\n        ops_by_fresh_item[fresh_item] = ops\n        ops.each do |op|\n          input = inputs.find { |input| op.input(input).item == item }\n          op.input(input).set item: fresh_item\n        end\n        if item.get(:contaminated) != \"Yes\"\n          transfer_table.push [item.id, {content: fresh_item.id, check: true}]\n        end\n      end\n    end\n    \n    take found_items, interactive: true if found_items.any?\n    #items are guilty untill proven innocent. all the fresh items will be put back into the list of items to check for volume\n    bad_ops_by_item.merge! ops_by_fresh_item\n    take stocks, interactive: true if stocks.any?\n    \n    # label new aliquot tubes and dilute\n    #show do \n    #  title \"Grab 1.5 mL tubes\"\n    #  \n    #  note \"Grab #{aliquots_to_make} 1.5 mL tubes\"\n    #  note \"Label each tube with the following ids: #{bad_ops_by_item.keys.reject { |item| found_items.include? item }.map { |item| item.id }.sort.to_sentence}\"\n    #  note \"Using the 100 uL pipette, pipette 90uL of water into each tube\"\n    #end if bad_ops_by_item.keys.reject { |item| found_items.include? item }.any?\n  \n    # make new aliquots\n    show do \n      title \"Convert enzyme stocks to aliquots and label with new IDs\"\n      \n      note \"Relabel enzyme stocks with the following IDs. These stocks will be converted to aliquots and stored in the small freezer.\"\n      note \"If the enzyme stock was already labelled with an old ID, clean it off before continuing.\"\n      table stock_table\n    end if stocks.any?\n    \n    \n    if transfer_table.length \u003e 1\n      show do\n        title \"Transfer residual enzyme to new aliquot\"\n        note \"Transfer residual enzyme from the low volume aliquots into the fresh aliquots according to the following table:\"\n        table transfer_table\n      end\n    end\n    \n    release stocks, interactive: true if stocks.any?\n  end\n\n    def nanodrop_dsdna items\n        conc_data = show do\n          title \"Please nanodrop the following items using dsDNA setting on nanodrop.\"\n          note \"Please nanodrop the following items using dsDNA setting on nanodrop and enter concentrations in ng/µl.\"\n          check \"Move the pipette tip in circles at the bottom of the tube for 10 seconds before nanodropping each item to ensure they are fully mixed.\"\n          items.each do |i|\n            get \"number\", var: \"c#{i.id}\", label: \"#{i} item ng/µl\", default:  (debug ? (Random.rand*1000) : 0)\n            get \"number\", var: \"A260280_#{i.id}\", label: \"#{i} item A260/A280\", default:  1.8\n            get \"number\", var: \"A260230_#{i.id}\", label: \"#{i} item A260/A230\", default:  1.8\n          end\n        end if items.any?\n        \n        items.each do |item|\n            if item.sample.properties[\"Length\"] == 0\n                item.associate(:concentration, nil)\n                item.associate(:concentration_keyword, \"UNKNOWN\")\n                item.append_notes \"Concentration of this item could not be calculated. Please enter length information.\"\n                item.save\n            else\n                conc_in_ng_per_ul = conc_data[\"c#{item.id}\".to_sym]\n                # Hard coded concentration adjustment for purify gel slice operation. Based on running gel extraction blank and measuring concentration.\n                if operations[0].operation_type.id == 482\n                    conc_in_ng_per_ul = [(conc_in_ng_per_ul - 2.7), 0.0].max\n                end\n                conc_in_mol_per_l = conc_in_ng_per_ul * 0.0000015150 / item.sample.properties[\"Length\"]\n                item.associate(:concentration, conc_in_mol_per_l)\n                item.associate(:A260280, conc_data[\"A260280_#{item.id}\".to_sym])\n                item.associate(:A260230, conc_data[\"A260230_#{item.id}\".to_sym])\n                item.associate(:volume, item.get(:volume).to_f - 1.0) if item.get(:volume)\n                item.save\n            end\n        end if items.any?\n    end\n      \n    def manually_enter_uM_conc items\n        conc_data = show do\n          title \"Please determine and enter concentrations of the following items in µM.\"\n          note \"Please determine and enter concentrations of the following items in µM.\"\n          warning \"Do not enter concentration in ng/ul or any unit other than µM.\"\n          items.each do |i|\n            get \"number\", var: \"c#{i.id}\", label: \"#{i} item\", default:  (debug ? Random.rand * 100 : 0)\n          end\n        end if items.any?\n        \n        items.each do |item|\n            item.associate(:concentration, conc_data[\"c#{item.id}\".to_sym] / 1000000.0)\n            item.save\n        end if items.any?\n    end\n\n    def assign_input_items inputs, input_volumes, current_taken_items\n        items_to_characterize = []\n        #finds all items matching input sample and object type\n        inputs.each do |input|\n            operations.running.each do |op|\n                if op.input_array(input).any?\n                    op.input_array(input).each do |input_fields|\n                        Array(input_fields.sample.in(input_fields.object_type.name)).each{|item| items_to_characterize \u003c\u003c item}\n                    end\n                end\n            end\n        end\n        \n        items_to_characterize.uniq!\n        items_to_release = characterize items_to_characterize, current_taken_items\n        robust_release items_to_release, current_taken_items, interactive: true\n        \n        operations.running.each do |op|\n            inputs.each do |input|\n                if op.input_array(input).any?\n                    item_array = []\n                    op.input_array(input).each do |input_fields|\n                        eligible_items = Array(input_fields.sample.in(input_fields.object_type.name)).select{|item| !item.deleted? \u0026\u0026 (!input_volumes.keys.include?(input) || item.get(:volume).to_f \u003e= input_volumes[input]) \u0026\u0026 !(item.get(:concentration_keyword) == \"UNKNOWN\") \u0026\u0026 !(item.get(:concentration_keyword) == \"UNKNOWN\")}\n                        #Use normal concentration items first, pick the smallest volume item\n                        eligible_items.sort_by! {|item| [(item.get(:concentration_keyword) == \"STANDARD\") ? 0 : 1, input_volumes.keys.include?(input) ? item.get(:volume).to_f : 1]}\n                        #if the item has custom wizards, get the item from the smallest custom wizard\n                        begin\n                            eligible_items.sort_by! {|item| item.object_type.data_object[:custom_wizards][item.locator.wizard.name.to_sym]} if input_fields.object_type.data_object[:custom_wizards]\n                        rescue\n                        end\n                        if eligible_items.any?\n                            item_array \u003c\u003c eligible_items[0]\n                            eligible_items[0].associate(:volume,(eligible_items[0].get(:volume).to_f - input_volumes[input].to_f).round(2)) if input_volumes.keys.include?(input)\n                            eligible_items[0].save\n                        else\n                            op.error :input_volume_error, \"Inadequate amount of input sample (name: #{op.input(input).sample.name} ID:#{op.input(input).sample.id}).\"\n                        end\n                    end\n                    if !(op.status == \"error\")\n                        item_array.each_with_index do |item, i|\n                            op.input_array(input)[i].set item: item\n                        end\n                    end\n                end\n            end\n        end\n    end\n    \n    def check_user_inputs inputs, input_volumes, current_taken_items\n        #Characterizes all possible input items rather than only user specified inputs simply to increase the number of characterized items in inventory\n        items_to_characterize = []\n        #finds all items matching input sample and object type\n        inputs.each do |input|\n            operations.running.each do |op|\n                if op.input_array(input).any?\n                    op.input_array(input).each do |input_fields|\n                        Array(input_fields.sample.in(input_fields.object_type.name)).each{|item| items_to_characterize \u003c\u003c item}\n                    end\n                end\n            end\n        end\n        \n        items_to_characterize.uniq!\n        items_to_release = characterize items_to_characterize, current_taken_items\n        robust_release items_to_release, current_taken_items, interactive: true\n        \n        #Check if user assigned items have sufficient volumes for operations\n        \n        operations.running.each do |op|\n            inputs.each do |input|\n                if op.input_array(input).any?\n                    op.input_array(input).items.each_with_index do |input_item, input_index|\n                        if !input_item.deleted? \u0026\u0026(!input_volumes.keys.include?(input) || input_item.get(:volume).to_f \u003e= input_volumes[input]) \u0026\u0026 input_item.get(:concentration_keyword) != \"UNKNOWN\"\n                            input_item.associate(:volume,(input_item.get(:volume).to_f - input_volumes[input].to_f).round(2)) if input_volumes.keys.include?(input)\n                            input_item.save\n                        else\n                            if input_item.get(:concentration_keyword) == \"UNKNOWN\"\n                                op.error :unknown_conc_error, \"Concentration of input item could not be calculated, please confirm that length is not set to zero (Item ID:#{input_item.id}, Sample Name: #{input_item.sample.name}).\"\n                            else\n                                op.error :input_volume_error, \"Inadequate amount of input item (Item ID:#{input_item.id}, Sample Name: #{input_item.sample.name}).\"\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\n      \n    def characterize all_items, current_taken_items\n        #returns the list of items but with low concentration ones deleted and high concentration ones diluted/spread out\n        #check if concentration_keyword is a string\n        #check if volume is there\n        #if there's a rec conc, nanodrop it.\n        #if length is 0, associate concentration_keyword: \"UNKNOWN\" and associate a warning. Otherwise\n        #tells the user to discard stuff or dilute stuff, deletes discarded items\n        #should always save volumes as being lower than they actually are\n        \n        items_to_return = all_items\n        \n        #Smoothly converts old concentration data (which was in ng/ul) to the new type\n        #TODO: delete this once all old inventory is transferred over\n        items_to_return.each do |item|\n            if item.get(:concentration) \u0026\u0026 item.get(:concentration_keyword).nil?\n                if item.object_type.data_object[:conc_callback] == \"nanodrop_dsdna\"\n                    conc_in_mol_per_l = item.get(:concentration).to_f * 0.0000015150 / item.sample.properties[\"Length\"]\n                    item.associate(:concentration, conc_in_mol_per_l)\n                    item.save\n                end\n            end\n        end\n        \n        #Smoothly detects and calculates concentrations of primer stocks from old system (which were at 100 uM)\n        #TODO: delete this once all old inventory is transferred over\n        items_to_return.each do |item|\n            if item.sample.sample_type.name == \"Primer\" \u0026\u0026 item.object_type.name == \"Primer Stock\" \u0026\u0026 item.get(:volume).nil? \u0026\u0026 item.created_at \u003c DateTime.new(2018,2,24)\n                item.associate(:concentration, 0.0001)\n                item.save\n            end\n        end\n        \n        items_requesting_delete = items_to_return.select{|i| !i.get(:delete_requested).nil?}\n        \n        robust_take items_requesting_delete, current_taken_items, interactive: true\n        \n        show do\n            title \"Discard items as requested by users.\"\n            note \"Some items have been requested for deletion by their respective users. Discard the following items:\"\n            note items_requesting_delete.map{|i| i.id}.to_sentence\n        end if items_requesting_delete.any?\n        \n        items_requesting_delete.each do |item|\n            items_to_return.delete(item)\n            item.mark_as_deleted\n        end\n        \n        items_to_measure_conc = items_to_return.reject {|item| item.object_type.data_object[:conc_callback].nil? || item.get(:concentration)}\n        robust_take items_to_measure_conc, current_taken_items, interactive: true\n        items_to_measure_conc_by_callback = {}\n        items_to_measure_conc.each do |item|\n            if !items_to_measure_conc_by_callback.keys.include? item.object_type.data_object[:conc_callback]\n                items_to_measure_conc_by_callback[item.object_type.data_object[:conc_callback]] = [item]\n            else\n                items_to_measure_conc_by_callback[item.object_type.data_object[:conc_callback]] \u003c\u003c item\n            end\n        end\n        items_to_measure_conc_by_callback.each do |callback, items|\n            method(callback.to_sym).call(items)\n        end\n        \n        items_to_discard = []\n        items_to_dilute = []\n        items_to_return.select{|item| item.get(:concentration)}.each do |item|\n            if item.get(:concentration).to_f \u003c item.object_type.data_object[:min_conc].to_f\n                items_to_discard \u003c\u003c item\n                item.mark_as_deleted\n                items_to_return.delete(item)\n                item.save\n            elsif (100.0*item.get(:concentration).to_f / item.object_type.data_object[:rec_conc].to_f).round \u003c 100\n                item.associate :concentration_keyword, \"LOW\"\n                item.append_notes \"\\nConcentration of this item is #{(100.0*item.get(:concentration).to_f / item.object_type.data_object[:rec_conc].to_f).round}% of recommended concentration. Yield of downstream applications may be reduced.\"\n                item.save\n            elsif (100.0*item.get(:concentration).to_f / item.object_type.data_object[:rec_conc].to_f).round \u003e 100\n                items_to_dilute \u003c\u003c item\n            else\n                item.associate :concentration_keyword, \"STANDARD\"\n            end\n        end\n        \n        robust_take items_to_discard, current_taken_items\n        \n        #check if any below minimum conc items are operation outputs and throw errors if they are\n        operations.running.each do |op|\n            op.outputs.each do |output|\n                if items_to_discard.include? output.item\n                    op.error :output_below_min_conc, \"Output item #{output.item.id} (#{output.sample.name}) was below the minimum concentration for its object type.\"\n                end\n            end\n        end\n        \n        show do\n            title \"Discard low concentration items.\"\n            note \"Some items are below the minimum concentration for their object type. Discard the following items:\"\n            note items_to_discard.map{|i| i.id}.to_sentence\n        end if items_to_discard.any?\n        \n        items_to_discard = []\n        items_to_measure_vol = items_to_return.reject {|item| item.get(:volume) || item.object_type.data_object[:max_vol].nil?}\n        robust_take items_to_measure_vol, current_taken_items, interactive: true if items_to_measure_vol.any?\n\n        vol_data = show do\n            title \"Measure volumes of the following items\"\n            note \"Measure volumes of the following items using a pipette or other appropriate means. Enter volumes in µl.\"\n            warning \"Remember to record volumes in µl and not ml.\"\n            items_to_measure_vol.each do |item|\n                get \"number\", var: \"v#{item.id}\", label: \"#{item} item\", default: (debug ? Random.rand*20.0 + 50.0 : 0)\n            end\n        end if items_to_measure_vol.any?\n        \n        items_to_measure_vol.each do |item|\n            if (vol_data[\"v#{item.id}\".to_sym].to_f)*0.95-2.0 \u003e 0.0\n                item.associate :volume, ((vol_data[\"v#{item.id}\".to_sym].to_f)*0.95-2.0)\n                item.save\n            else\n                items_to_discard \u003c\u003c item\n                item.mark_as_deleted\n                items_to_dilute.delete(item) if items_to_dilute.include? item\n                items_to_return.delete(item)\n                item.save\n            end\n        end\n        \n        show do\n            title \"Discard low volume items.\"\n            note \"Discard the following low volume items:\"\n            check items_to_discard.map{|i| i.id}.to_sentence\n        end if items_to_discard.any?\n        \n        split_counts_by_item = {}\n        items_to_dilute.each do |item|\n            if item.get(:concentration) \u0026\u0026 item.get(:volume)\n                split_count = ((item.get(:concentration).to_f * item.get(:volume).to_f / item.object_type.data_object[:rec_conc].to_f) / item.object_type.data_object[:max_vol].to_f).ceil\n                if (split_count \u003e 0 \u0026\u0026 split_count \u003c 100) #guards against accidental overload due to messy data\n                    split_counts_by_item[item] = split_count\n                else\n                    raise \"Split count error (see \\\"Cloning Libs/Cloning\\\" library. Split count was set to #{split_count} due to bad concentration or volume information.\"\n                end\n            end\n        end\n        \n        robust_take items_to_dilute, current_taken_items, interactive: true if items_to_dilute.any?\n        \n        show do \n            title \"Split contents of high concentration items to new containers before diluting.\"\n            note \"For pipetting accuracy reasons, the following items will be diluted in new tubes, and the original item tubes will be emptied and discarded.\"\n            split_counts_by_item.reject{|i, c| c == 1}.each do |item, split_count|\n                new_items = []\n                split_volume = (item.get(:volume).to_f / split_count.to_f)\n                item.associate(:volume, split_volume.round(2))\n                item.save\n                (split_count-1).times do\n                    new_item = produce new_sample item.sample.name, of: item.sample.sample_type.name, as: item.object_type.name\n                    pass_data *(item.associations.keys), from: item, to: new_item\n                    new_item.save\n                    new_item.associate(:volume, split_volume.round(2))\n                    new_item.save\n                    current_taken_items \u003c\u003c new_item\n                    items_to_return \u003c\u003c new_item\n                    items_to_dilute \u003c\u003c new_item\n                    new_items \u003c\u003c new_item\n                end\n                check \"Transfer #{item.get(:volume).round(2)} µl from item #{item.id} to #{split_count} new containers labelled #{(new_items.map{|i| i.id} \u003c\u003c item.id).to_sentence}.\"\n                check \"Discard the original (now empty) container for #{item.id}\"\n            end\n        end if split_counts_by_item.any? {|i, c| c \u003e 1}\n        \n        show do\n            title \"Dilute the following items\"\n            check \"Dilute items according to the following table:\"\n            table_matrix = Array.new(items_to_dilute.count+1) {Array.new}\n            table_matrix[0] = [\"Item ID\", \"Water to add\"]\n            items_to_dilute.each_with_index do |item, item_index|\n                dilution_factor = item.get(:concentration).to_f / item.object_type.data_object[:rec_conc].to_f\n                volume_to_add = ((dilution_factor - 1.0)*item.get(:volume).to_f).round(2)\n                new_volume = ((item.get(:volume).to_f+volume_to_add)*0.95-2.0).round(2)\n                item.associate(:volume, new_volume)\n                item.associate(:concentration, item.object_type.data_object[:rec_conc].to_f)\n                item.associate(:concentration_keyword, \"STANDARD\")\n                item.save\n                table_matrix[item_index+1] = [item.id.to_s, {content: \"#{volume_to_add} µl of water\", check: true}]\n            end\n            table table_matrix\n        end if items_to_dilute.any?\n        \n        return items_to_return\n    end\n      \n    def store_outputs_with_volumes output_volumes, current_taken_items, args = {}\n        options = {\n            interactive: false,\n            method: \"boxes\"\n            }.merge args\n        items_to_characterize = []\n        output_volumes.each do |output, vol|\n            operations.running.each do |op|\n                if op.output_array(output)\n                    op.output_array(output).items.each do |item|\n                        item.associate(:volume, vol.round(2))\n                        item.save\n                        items_to_characterize \u003c\u003c item\n                    end\n                end\n            end\n        end\n        if options[:interactive]\n            characterize items_to_characterize, current_taken_items\n        end\n        robust_release items_to_characterize, current_taken_items, options\n    end\n      \n    def robust_take items, current_taken_items, options={}\n        items.uniq!\n        items_to_take = items.reject{|item| current_taken_items.include? item || item.deleted?}\n        take items_to_take, options if items_to_take.any?\n        items_to_take.each{|i| current_taken_items \u003c\u003c i}\n    end\n      \n    def robust_release items, current_taken_items, options={}\n        items.uniq!\n        items.reject! {|item| (!current_taken_items.include? item) || item.deleted?}\n        #Workaround to allow defining custom wizards in object_type data. Should be rewritten if custom wizard functionality is built in.\n        items.each do |item|\n            #similar to internal structure of item.store but supports custom wizards\n            custom_wizards = item.object_type.data_object[:custom_wizards]\n            if !(custom_wizards.nil?)\n                stored = false\n                wiz_index = 0\n                while !stored \u0026\u0026 wiz_index \u003c custom_wizards.keys.count\n                    already_in_wiz = false\n                    wiz_name = custom_wizards.keys[wiz_index]\n                    max_in_wiz = custom_wizards[wiz_name]\n                    wiz = Wizard.find_by_name(wiz_name.to_s)\n                    num_in_wiz = 0\n                    #check how many items are already there (other than the one being stored)\n                    item.sample.items.each do |i|\n                        if i.locator_id \u0026\u0026 Locator.find(i.locator_id).wizard.id == wiz.id\n                            if i == item\n                                already_in_wiz = true\n                                stored = true\n                            else\n                                num_in_wiz += 1\n                            end\n                        end\n                    end\n                    if !already_in_wiz \u0026\u0026 num_in_wiz \u003c max_in_wiz.round\n                        #Closely mimics store and move_to in item.rb but with wizard not determined by object type.\n                        locator = wiz.next\n                        locstr = wiz.int_to_location locator.number\n                        locs = Locator.where(wizard_id: wiz.id, number: (wiz.location_to_int locstr))\n                        \n                        case locs.length \n                        when 0\n                            newloc = wiz.addnew locstr\n                        when 1\n                            newloc = locs.first \n                        end\n                        \n                        if newloc.item_id == nil\n                            oldloc = Locator.find_by_id(item.locator_id)\n                            oldloc.item_id = nil if oldloc\n                            item.locator_id = newloc.id\n                            item.set_primitive_location(locstr)\n                            item.quantity = 1\n                            item.inuse = 0\n                            newloc.item_id = item.id\n                            item.save\n                            oldloc.save if oldloc\n                            newloc.save\n                            item.reload\n                            oldloc.reload if oldloc\n                            newloc.reload\n                        end\n                        stored = true\n                    end\n                    wiz_index += 1\n                end\n            end\n        end\n        release items, options if items.any?\n        items.each{|i| current_taken_items.delete(i)}\n    end\n      \n    def robust_take_inputs inputs, current_taken_items, options={}\n        item_list = []\n        inputs.each do |input|\n            operations.running.each do |op|\n                if op.input_array(input).any?\n                    op.input_array(input).items.each do |item|\n                        item_list \u003c\u003c item\n                    end\n                end\n            end\n        end\n        robust_take item_list, current_taken_items, options\n    end\n      \n    def robust_release_inputs inputs, current_taken_items, options={}\n        item_list = []\n        inputs.each do |input|\n            operations.running.each do |op|\n                if op.input_array(input).any?\n                    op.input_array(input).items.each do |item|\n                        item_list \u003c\u003c item\n                    end\n                end\n            end\n        end\n        \n        empty_item_list = item_list.select{|i| i.get(:volume) \u0026\u0026 i.get(:volume).to_f \u003c= 1.0} #TODO: change to something more flexible (rather than just deleting if below 1 ul)\n        empty_item_list.each do |i| \n            i.mark_as_deleted\n            i.save\n        end\n        \n        show do\n            title \"Discard low volume items.\"\n            note \"Discard the following low volume items:\"\n            check empty_item_list.map{|item| item.id}.uniq.to_sentence\n        end if empty_item_list.any?\n        robust_release item_list, current_taken_items, options\n    end\n      \n    def robust_make outputs, current_taken_items\n        operations.running.make only: outputs\n        outputs.each do |output|\n            operations.running.each do |op|\n                if op.output_array(output).any?\n                    op.output_array(output).items.each do |item|\n                        current_taken_items \u003c\u003c item\n                    end\n                end\n            end\n        end\n    end\n    \n    def send_error_emails operations\n        ops_by_user = {}\n        operations.each do |op|\n            user = User.find(op.user_id)\n            if ops_by_user.keys.include? user\n                ops_by_user[user] \u003c\u003c op\n            else\n                ops_by_user[user] = [op]\n            end\n        end\n        ops_by_user.each do |user, ops|\n            body = \"\n            Hello #{user.name},\u003cbr/\u003e\u003cbr/\u003e\n            The following operations submitted to DAMP Lab North have failed. Please review your \u003ca href=\\\"http://54.190.2.203/launcher\\\"\u003eplanner\u003c/a\u003e or email #{Parameter.get_string('smtp_email_address')} for more information.\u003cbr/\u003e\u003cbr/\u003e\n            #{\n                ops.map { |op|\n                    op.associations.map{|key, value| \"\u003cb\u003eOperation ID:\u003c/b\u003e #{op.id} \u003cb\u003eOperation Name:\u003c/b\u003e #{op.name} \u003cb\u003ePlan:\u003c/b\u003e #{op.plan.id} \u003cb\u003eInfo:\u003c/b\u003e #{key}, #{value}\"}}.join(\"\u003cbr/\u003e\")\n            }\"\n            if user.parameters.find { |p| p.key == 'email'}\n                send_email user.name, user.parameters.find { |p| p.key == 'email'}.value, \"DAMP Lab Job Failure Alert\", body\n            end\n        end\n    end\n    \n    #Takes an hash of file contents (already opened with File.read) with filenames as keys\n    def send_email to_name, to_address, subject, body, file_paths={}\n        if debug\n            to_address = \"nickemery23@gmail.com\"\n        end\n        \n        encoded_files = {}\n        file_paths.each do |file_name, file_path|\n            encoded_files[file_name] = [File.read(file_path)].pack(\"m\")\n        end\n        \n        marker = (Random.rand(1000000000) + 1000000000).to_s\n        #Not using \u003c\u003cEOF because it messes up Aq text coloring\n        msg_str =\n        [\"From: DAMP Lab North Aquarium \u003c#{Parameter.get_string('smtp_email_address')}\u003e\",\n        \"To: #{to_name} \u003c#{to_address}\u003e\",\n        \"Subject: #{subject}\",\n        \"Mime-Version: 1.0\",\n        \"Content-Type: multipart/alternative; boundary=#{marker}\",\n        \"\",\n        \"--#{marker}\",\n        \"Content-Type: text/plain; charset=us-ascii\",\n        \"\",\n        \"...\",\n        \"--#{marker}\",\n        \"Content-Type: text/html\",\n        \"Content-Transfer-Encoding:7bit\",\n        \"Content-Disposition: inline\",\n        \"\",\n        \"\u003chtml\u003e\",\n        \"\u003cbody\u003e\",\n        \"#{body}\u003cbr/\u003e\u003cbr/\u003e\",\n        \"This is an automated email alert from the \u003ca href=\\\"http://54.190.2.203\\\"\u003eDAMP Lab Aquarium system\u003c/a\u003e.\",\n        \"\u003c/body\u003e\",\n        \"\u003c/html\u003e\\n\"].join(\"\\n\")\n        if encoded_files.any?\n            msg_str \u003c\u003c \"--#{marker}\\n\"\n            msg_str \u003c\u003c encoded_files.map{ |file_name, file_content|\n                [\"Content-Type: multipart/mixed; name = #{file_name};\",\n                \"Content-Transfer-Encoding:base64\",\n                \"Content-Disposition: attachment; filename = #{file_name}\",\n                \"\",\n                \"#{file_content}\"].join(\"\\n\")\n            }.join(\"--#{marker}\\n\")\n        end\n        msg_str \u003c\u003c \"--#{marker}--\\n\"\n        smtp = Net::SMTP.new Parameter.get_string('smtp_email_server'), Parameter.get_float('smtp_email_port').round\n        smtp.enable_starttls\n        smtp.start('localhost', Parameter.get_string('smtp_email_address'), Parameter.get_string('smtp_email_password'), :login) do\n            smtp.send_message(msg_str, Parameter.get_string('smtp_email_address'), to_address)\n        end\n    end\n    \n    #Methods in this module are added to the ShowBlock class directly, allowing them to be called inside a show block. Example:\n    #show do\n    #   title \"Centrifuge the spin columns\"\n    #   centrifuge operations.running.count, 13000, 1\n    #end\n    module CloningMixin\n        #Shows an image representing the correct centrifuge layout for n tubes in a 24 well centrifuge.\n        #If n is 1 or 23, explains that a balance tube must be used. If n \u003e 24, shows image for 24 tubes and image for remaining tubes (recursive).\n        def centrifuge n, rpm, min\n            @parts.push({check: \"Centrifuge at #{rpm} RPM for #{min} #{'minute'.pluralize(min)}.\"})\n            while n \u003e 0\n                if n == 1 || n == 23\n                    @parts.push({check: \"Create a balance tube of the same weight as the #{'tube'.pluralize(n)} you are spinning down.\"})\n                    n += 1\n                end\n                if n \u003e= 24\n                    @parts.push({image: \"#{Bioturk::Application.config.image_server_interface}centrifuge_layouts/24Tubes.png\"})\n                    n -= 24\n                else\n                    @parts.push({image: \"#{Bioturk::Application.config.image_server_interface}centrifuge_layouts/#{n}Tubes.png\"})\n                    n = 0\n                end\n            end\n        end\n    end\n    ShowBlock.class_eval { include CloningMixin }\nend"}}]}