{"config":{"title":"OpenTronsAq","description":"No description given","copyright":"No copyright declared","version":"no version info","authors":[],"maintainer":{"name":"No maintainer","email":"noone@nowehere"},"acknowledgements":[],"github":{"repo":"none","user":"none","access_token":"none"},"keywords":[],"aquadoc_version":"1.0.0"},"components":[{"library":{"name":"OpenTronsAq","category":"Cloning Libs","code_source":"require 'json'\r\n# require 'opentrons'\r\nneeds \"Cloning Libs/OpenTronsMonkey\"\r\nneeds \"Standard Libs/Debug Lib\"\r\n\r\n# These slots won't be filled automatically but can still have labware assigned to them explicitly.\r\nRESERVED_SLOTS=['10']\r\n\r\nmodule OpenTronsAq\r\n    include Debug\r\n    \r\n    #include OpenTrons\r\n    include OpenTronsMonkey\r\n    # Opentrons.class_eval { include OpenTronsMonkey}\r\n    \r\n    def run_protocol(protocol)\r\n        filename = 'OT2_protocol_' + (rand(1000) + 100).to_s + '.py'\r\n        \r\n        file = Tempfile.new(filename)\r\n        file.write(protocol.text)\r\n        file.close\r\n        \r\n       # u = Upload.new\r\n        # File.open(file.path) do |f|\r\n         #    u.upload = f\r\n          # u.name = filename\r\n           #  u.job_id = operations[0].jobs[-1].id\r\n            # u.save\r\n             # operations.each do |operation|\r\n               # operation.associate :protocol_file, \"File upload #{filename}\", u, duplicates: true \r\n            # end\r\n        # end\r\n        \r\n        #DEBUGGING:\r\n        # show do\r\n        #     protocol.rack_layouts.each do |layout|\r\n        #         note \"layouts are #{layout}\"\r\n        #     end\r\n        # end\r\n        \r\n        show do\r\n            title \"Run protocol on OT2 robot\"\r\n            # u.url\r\n            #check \"\u003ca href=\\\"#{u.url}\\\" download=\\\"#{filename}\\\"\u003eDownload OpenTrons Protocol\u003c/a\u003e\"\r\n            check \"Drag protocol into OT2 app and follow instructions to calibrate.\"\r\n\r\n            protocol.rack_layouts.each do |layout|\r\n                table_matrix = Array.new\r\n                layout[\"layout\"].each_with_index do |row, i|\r\n                    table_matrix[i] = Array.new #added during the meeting\r\n                    # note \"row is : #{row} and i is #{i}\"\r\n                    row.each_with_index do |item, j|\r\n                        # note \"i is #{i} and j is #{j} and itemid is #{item.id}\"\r\n                        if !(item) || (item.is_a?(AqDummyItem) \u0026\u0026 !(item.name))\r\n                            table_matrix[i][j] = \"None\"\r\n                        elsif item.is_a? AqDummyItem\r\n                            table_matrix[i][j] = {content: item.name, check: true}\r\n                        else\r\n                            table_matrix[i][j] = {content: \"Item ID: #{item.id}\", check: true} \r\n                        end\r\n                    end\r\n                end\r\n                \r\n                check \"Load items into #{layout[\"display_name\"]} (#{layout[\"model\"]}) according to the following table:\"\r\n                table table_matrix\r\n            end\r\n            \r\n            warning \"Warning: remove all caps from tubes and carefully follow instructions in the app!\"\r\n            warning \"Never load frozen items onto the deck!\"\r\n\r\n            check \"Set up OT2 deck according to the following table:\"\r\n            table protocol.deck_layout\r\n            \r\n            check \"Run OT2 protocol using the app.\"\r\n        end\r\n    end\r\n    \r\n    class OTAqProtocol \u003c OTProtocol\r\n        \r\n        include Debug\r\n        \r\n        def initialize(params: {})\r\n            super(params)\r\n            designer_application = \"OpenTronsAq\"\r\n            @labware_definitions = []\r\n            @wells_by_item_id = {}\r\n        end\r\n        \r\n        def to_hash\r\n            as_hash = super\r\n            as_hash[\"labware-definitions\"] = @labware_definitions\r\n            return as_hash\r\n        end\r\n        \r\n        def text\r\n            return \"jp = \" + to_json + \"\\n\\n\" + get_code('Universal OT Template').content\r\n        end\r\n        \r\n        # Note: This is really hacky for multiple reasons.\r\n        # Adds a labware definition from an Aquarium library.\r\n        def add_labware_definition(name)\r\n            @labware_definitions \u003c\u003c JSON.parse(get_code(name).content)\r\n            labware.labware_definitions \u003c\u003c JSON.parse(get_code(name).content)\r\n        end\r\n        \r\n        def find_well(aq_item)\r\n            return @wells_by_item_id[aq_item.id]\r\n        end\r\n\r\n        # Generates a list of hashes with display names, models, and contents of labware as keys and 2D arrays of aq items (or nils)\r\n        def rack_layouts\r\n            layouts = []\r\n            labware.labware_hash.each do |key, labware_item|\r\n                current_layout = {\"display_name\" =\u003e labware_item.display_name, \"layout\" =\u003e [], \"model\" =\u003e labware_item.model}\r\n                at_least_one_item = false\r\n                labware_item.well_list.each_with_index do |col, j|\r\n                    col.each_with_index do |well, i|\r\n                        if current_layout[\"layout\"][i].nil?\r\n                            current_layout[\"layout\"][i] = Array.new\r\n                        end\r\n                        current_layout[\"layout\"][i][j] = well.item\r\n                        at_least_one_item = true if well.item\r\n                    end\r\n                end\r\n                layouts \u003c\u003c current_layout if at_least_one_item\r\n            end\r\n            return layouts\r\n        end\r\n\r\n        # Returns deck layout as a 2D array ready to be displayed in Aq with table krill command.\r\n        def deck_layout\r\n            layout = Array.new(4) {Array.new(3) {\"None\"}}\r\n            labware.labware_hash.each do |key, labware_item|\r\n                i = 3 - ((labware_item.slot.to_i - 1) / 3)\r\n                j = (labware_item.slot.to_i - 1) % 3\r\n                layout[i][j] = {content: \"Name: #{labware_item.display_name}, Model: #{labware_item.model}\", check: true}\r\n            end\r\n            return layout\r\n        end\r\n        \r\n        # Finds a Code by the name of its Library\r\n        private def get_code name\r\n            lib = Library.where(name: name)[-1]\r\n            # return most recent version.\r\n            return Code.where(parent_id: lib.id)[-1]\r\n        end\r\n\r\n        # Allocates a number of wells, reserving and returning them as an Array. Will create new labware \r\n        # of labware_type if create_labware = 1 (default) and no well is found. create_labware of 0 never \r\n        # creates labware. create_labware of 2 always creates labware.\r\n        def allocate_wells(num, labware_type, create_labware: 1)\r\n            allocated_wells = []\r\n            labware_item = get_labware_item labware_type, create_labware\r\n\r\n            num.times do\r\n                well = find_avail_well labware_item\r\n                if !well\r\n                    labware_item = get_labware_item labware_type, 2\r\n                    well = find_avail_well labware_item\r\n                end\r\n\r\n                well.allocated = true\r\n                allocated_wells \u003c\u003c well\r\n            end\r\n\r\n            return allocated_wells\r\n        end\r\n\r\n        # Assigns wells to items and returns wells. Also adds well data assoc to items.\r\n        # Warning: currently cannot handle items w/ multiple labware types.\r\n        def assign_wells(aq_items, wells=nil, create_labware: 1) \r\n            if wells\r\n                if !(wells.length == aq_items.length)\r\n                    aq_items.collection? ## checking if this is a collection\r\n                    raise ArgumentError.new \"Number of items (#{aq_items.length}) and wells (#{wells.length}) do not match.\"\r\n                end\r\n            else\r\n                labware_type = aq_items[0].object_type.data_object[:opentrons_labware]\r\n                if labware_type\r\n                    wells = allocate_wells aq_items.length, labware_type, create_labware: create_labware\r\n                else\r\n                    raise ArgumentError.new \"No opentrons_labware value found for Container type #{aq_items[0].object_type}.\"\r\n                end\r\n            end\r\n\r\n            wells.each_with_index do |well, i|\r\n                well.item = aq_items[i]\r\n                #aq_items[i].well = well\r\n                @wells_by_item_id[aq_items[i].id] = well\r\n            end\r\n        end\r\n\r\n        def dummy_item(name=nil)\r\n            return AqDummyItem.new(name)\r\n        end\r\n\r\n        # Utility function for finding unallocated well in labware item.\r\n        private def find_avail_well(labware_item)\r\n            labware_item.wells.each do |well|\r\n                if !(well.allocated)\r\n                    return well\r\n                end\r\n            end\r\n            return nil\r\n        end\r\n\r\n        # Utility function for creating or finding labware items.\r\n        private def get_labware_item(labware_type, create_labware)\r\n            if create_labware == 2\r\n                return labware.load(labware_type, labware.free_slots[-1], \"#{labware_type}-#{labware.free_slots[-1]}\")\r\n            else\r\n                labware.labware_hash.each do |key, labware_item|\r\n                    if labware_item.model == labware_type\r\n                        return labware_item\r\n                    end\r\n                end\r\n\r\n                # If nothing was found, create new or throw error.\r\n                if create_labware == 1\r\n                    return labware.load(labware_type, labware.free_slots[-1], \"#{labware_type}-#{labware.free_slots[-1]}\")\r\n                else\r\n                    raise ArgumentError.new \"create_labware set to 0 (never) and no well of type #{labware_type} found.\"\r\n                end\r\n            end\r\n        end\r\n    end\r\n    \r\n    module WellMixin\r\n        attr_accessor :item, :allocated\r\n    end\r\n    OpenTronsMonkey::Well.class_eval {include WellMixin}\r\n    #OpenTrons::Well.class_eval {include WellMixin}\r\n    \r\n    # very bad\r\n    class OpenTronsMonkey::Labware\r\n        alias_method :old_free_slots, :free_slots\r\n        \r\n        def free_slots\r\n            slots = (1..12).to_a.map{|x| x.to_s}\r\n\t\t\ttaken_slots = labware_hash.map {|key, item| item.slot}\r\n\t\t\treturn slots.select{|x| !(taken_slots.include? x)} - RESERVED_SLOTS\r\n        end\r\n    end\r\n    \r\n    # This item behaves like an Aq item for purposes of the module, but is not added to the Aquarium database.\r\n    class AqDummyItem\r\n        attr_accessor :name, :id\r\n        def initialize(name=nil)\r\n            @name = name\r\n            @id = rand(100000)\r\n        end\r\n    end\r\nend"}}]}